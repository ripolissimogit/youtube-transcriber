#!/usr/bin/env python3
import sys
import os
import tempfile
import subprocess
import re
import glob
import requests
import json
from datetime import datetime

# Assicura che Homebrew sia nel PATH
homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
current_path = os.environ.get("PATH", "")
for path in homebrew_paths:
    if path not in current_path:
        os.environ["PATH"] = f"{path}:{current_path}"

# Aggiungi yt-dlp PATH specifico per Homebrew
ytdlp_paths = glob.glob("/opt/homebrew/Cellar/yt-dlp/*/bin")
for path in ytdlp_paths:
    if path not in current_path:
        os.environ["PATH"] = f"{path}:{os.environ['PATH']}"

VERSION = "3.3.0"

def check_for_updates():
    """Controlla se √® disponibile un aggiornamento"""
    try:
        response = requests.get("https://api.github.com/repos/ripolissimogit/youtube-transcriber/releases/latest", timeout=5)
        if response.status_code == 200:
            latest = response.json()["tag_name"].replace("v", "")
            if latest != VERSION:
                print(f"üÜï Aggiornamento disponibile: v{latest} (attuale: v{VERSION})")
                print("üí° Per aggiornare: curl -sSL https://raw.githubusercontent.com/ripolissimogit/youtube-transcriber/main/install-sbobina.sh | bash")
                print()
                return True
            else:
                print(f"‚úÖ Hai gi√† l'ultima versione: v{VERSION}")
                return False
        else:
            print("‚ö†Ô∏è Impossibile verificare aggiornamenti (GitHub API non disponibile)")
            return False
    except Exception as e:
        print("‚ö†Ô∏è Controllo aggiornamenti non disponibile (connessione limitata)")
        return False

def get_video_metadata(url):
    """Ottiene metadati del video YouTube"""
    try:
        cmd = ['yt-dlp', '--dump-json', '--no-download', url]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            return {
                'title': data.get('title', 'N/A'),
                'channel': data.get('uploader', 'N/A'),
                'upload_date': data.get('upload_date', 'N/A'),
                'duration': data.get('duration', 0),
                'view_count': data.get('view_count', 0),
                'description': data.get('description', '')[:200] + '...' if data.get('description') else 'N/A'
            }
    except:
        pass
    return {
        'title': 'N/A', 'channel': 'N/A', 'upload_date': 'N/A', 
        'duration': 0, 'view_count': 0, 'description': 'N/A'
    }

def improve_transcript_with_openai(transcript, api_key):
    """Migliora la trascrizione correggendo solo errori formali"""
    prompt = f"""Correggi SOLO gli errori formali in questa trascrizione senza alterare il contenuto:

COMPITI OBBLIGATORI:
1. Correggi errori di battitura e ortografia
2. Aggiungi punteggiatura corretta
3. Dividi in paragrafi logici
4. Mantieni ESATTAMENTE le stesse parole e il tono originale
5. NON aggiungere, rimuovere o modificare il significato

TRASCRIZIONE:
{transcript}

Rispondi SOLO con il testo corretto, senza commenti."""

    response = requests.post(
        'https://api.openai.com/v1/chat/completions',
        headers={
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        },
        json={
            'model': 'gpt-4o-mini',
            'messages': [{'role': 'user', 'content': prompt}],
            'max_tokens': 4000,
            'temperature': 0.1
        }
    )
    
    if response.status_code != 200:
        raise Exception(f"Errore OpenAI: {response.status_code}")
    
    return response.json()['choices'][0]['message']['content']

def generate_summary(transcript, api_key):
    """Genera sintesi del contenuto"""
    prompt = f"Scrivi una sintesi di massimo 3 frasi del seguente testo:\n\n{transcript}"
    
    response = requests.post(
        'https://api.openai.com/v1/chat/completions',
        headers={
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        },
        json={
            'model': 'gpt-4o-mini',
            'messages': [{'role': 'user', 'content': prompt}],
            'max_tokens': 200,
            'temperature': 0.3
        }
    )
    
    if response.status_code != 200:
        raise Exception(f"Errore sintesi: {response.status_code}")
    
    return response.json()['choices'][0]['message']['content']

def clean_youtube_url(url):
    """Pulisce URL YouTube da parametri di tracking"""
    # Estrae solo video ID
    patterns = [
        r'(?:youtube\.com/watch\?v=|youtu\.be/)([a-zA-Z0-9_-]{11})',
        r'youtube\.com/embed/([a-zA-Z0-9_-]{11})',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            video_id = match.group(1)
            return f"https://youtu.be/{video_id}"
    
    return url

def get_api_keys():
    """Ottieni entrambe le chiavi API (obbligatorie)"""
    groq_key = os.getenv('GROQ_API_KEY')
    openai_key = os.getenv('OPENAI_API_KEY')
    
    if not groq_key or not openai_key:
        print("‚ùå Chiavi API mancanti")
        if input("Vuoi configurarle ora? (s/n): ").lower().startswith('s'):
            return setup_api_keys()
        else:
            print("üí° Configura manualmente:")
            print("export GROQ_API_KEY='la_tua_chiave_groq'")
            print("export OPENAI_API_KEY='la_tua_chiave_openai'")
            return False, False
    return groq_key, openai_key

def setup_api_keys():
    """Configura entrambe le chiavi API (obbligatorie)"""
    print("\nüîë Configurazione API Keys (ENTRAMBE OBBLIGATORIE)")
    print("1. Groq API: https://console.groq.com/keys")
    print("2. OpenAI API: https://platform.openai.com/api-keys")
    print()
    
    groq_key = input("Incolla qui la tua chiave Groq API: ").strip()
    openai_key = input("Incolla qui la tua chiave OpenAI API: ").strip()
    
    if not groq_key or not openai_key:
        print("‚ùå Entrambe le chiavi sono obbligatorie")
        return False, False
    
    # Salva in entrambi i file di configurazione
    shell_files = ["~/.zshrc", "~/.bashrc"]
    for shell_file in shell_files:
        file_path = os.path.expanduser(shell_file)
        if os.path.exists(file_path):
            # Rimuovi vecchie configurazioni se presenti
            with open(file_path, "r") as f:
                lines = f.readlines()
            
            # Filtra le vecchie chiavi
            new_lines = []
            skip_next = False
            for line in lines:
                if "# YouTube Transcriber" in line:
                    skip_next = True
                    continue
                if skip_next and ("GROQ_API_KEY" in line or "OPENAI_API_KEY" in line):
                    continue
                skip_next = False
                new_lines.append(line)
            
            # Aggiungi nuove chiavi
            with open(file_path, "w") as f:
                f.writelines(new_lines)
                f.write(f"\n# YouTube Transcriber\nexport GROQ_API_KEY=\"{groq_key}\"\n")
                f.write(f"export OPENAI_API_KEY=\"{openai_key}\"\n")
    
    # Imposta per sessione corrente
    os.environ['GROQ_API_KEY'] = groq_key
    os.environ['OPENAI_API_KEY'] = openai_key
    
    print("‚úÖ Chiavi API configurate e attive!")
    print("üí° Le chiavi sono gi√† disponibili in questa sessione")
    return groq_key, openai_key

def show_help():
    """Mostra aiuto"""
    print("""
üé• YouTube Transcriber - Aiuto

üìñ USO:
  transcribe                          # Modalit√† interattiva
  trascrivi                           # Modalit√† interattiva (italiano)
  transcribe URL_YOUTUBE              # Trascrivi video
  trascrivi https://youtu.be/abc123   # Trascrivi video (italiano)
  transcribe /path/file.mp3           # Trascrivi file audio
  transcribe --help                   # Mostra questo aiuto
  transcribe --setup                  # Configura API key

üìù ESEMPI:
  transcribe https://youtu.be/dQw4w9WgXcQ
  trascrivi https://youtu.be/dQw4w9WgXcQ
  transcribe /Users/nome/audio.mp3

üîß CONFIGURAZIONE:
  - Serve una chiave API Groq gratuita
  - Ottienila da: https://console.groq.com/keys
  - Limite: 25MB per file audio

üí° SUGGERIMENTI:
  - Puoi incollare URL senza virgolette
  - I parametri di tracking vengono rimossi automaticamente
  - Formati supportati: mp3, m4a, wav, webm, ogg, flac
  - Funziona con entrambi i comandi: transcribe e trascrivi
""")

def interactive_mode():
    """Modalit√† interattiva per utenti non tecnici"""
    print("üé• YouTube Transcriber")
    print("=" * 30)
    
    while True:
        print("\nüìã Cosa vuoi fare?")
        print("1. Trascrivere video YouTube")
        print("2. Trascrivere file audio locale")
        print("3. Configurare API key")
        print("4. Controlla aggiornamenti")
        print("5. Aiuto")
        print("6. Esci")
        
        choice = input("\nScegli (1-6): ").strip()
        
        if choice == "1":
            url = input("\nüìé Incolla URL YouTube (senza virgolette): ").strip()
            if url:
                process_youtube(url)
        elif choice == "2":
            file_path = input("\nüìÅ Percorso file audio: ").strip()
            if file_path:
                process_audio_file(file_path)
        elif choice == "3":
            setup_api_keys()
        elif choice == "4":
            print("\nüîç Controllo aggiornamenti...")
            check_for_updates()
        elif choice == "5":
            show_help()
        elif choice == "6":
            print("üëã Arrivederci!")
            break
        else:
            print("‚ùå Scelta non valida")

def extract_audio_from_youtube(url):
    """Estrae audio da YouTube"""
    import tempfile
    temp_dir = tempfile.mkdtemp()
    base_name = os.path.join(temp_dir, "audio")
    
    cmd = ['yt-dlp', '--extract-audio', '--audio-format', 'mp3', 
           '--audio-quality', '64K', '-o', base_name, url]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Errore download: {result.stderr.strip()}")
    
    # Trova il file scaricato
    files = glob.glob(base_name + '*.mp3')
    if not files:
        raise Exception("File audio non trovato")
    
    return files[0]

def transcribe_audio(audio_file, api_key):
    """Trascrivi con Groq usando requests"""
    import requests
    
    with open(audio_file, 'rb') as f:
        response = requests.post(
            'https://api.groq.com/openai/v1/audio/transcriptions',
            headers={'Authorization': f'Bearer {api_key}'},
            files={'file': f},
            data={'model': 'whisper-large-v3', 'language': 'it'}
        )
    
    if response.status_code != 200:
        raise Exception(f"Errore API: {response.status_code}")
    
    return response.json().get('text', '')

def process_youtube(url):
    """Processa video YouTube"""
    groq_key, openai_key = get_api_keys()
    if not groq_key or not openai_key:
        return
    
    try:
        # Pulisci URL
        clean_url = clean_youtube_url(url)
        if clean_url != url:
            print(f"üßπ URL pulito: {clean_url}")
        
        # Ottieni metadati video
        print("üìä Recuperando metadati video...")
        metadata = get_video_metadata(clean_url)
        
        print("üì• Scaricando audio...")
        audio_file = extract_audio_from_youtube(clean_url)
        
        size_mb = os.path.getsize(audio_file) / (1024 * 1024)
        if size_mb > 25:
            print(f"‚ö†Ô∏è File troppo grande: {size_mb:.1f}MB (limite: 25MB)")
            return
        
        print(f"üé§ Trascrivendo... ({size_mb:.1f}MB)")
        raw_transcript = transcribe_audio(audio_file, groq_key)
        
        # Cleanup
        os.unlink(audio_file)
        
        print("ü§ñ Migliorando trascrizione...")
        improved_transcript = improve_transcript_with_openai(raw_transcript, openai_key)
        
        print("üìù Generando sintesi...")
        summary = generate_summary(improved_transcript, openai_key)
        
        # Formatta data
        upload_date = metadata['upload_date']
        if upload_date != 'N/A' and len(upload_date) == 8:
            formatted_date = f"{upload_date[:4]}-{upload_date[4:6]}-{upload_date[6:8]}"
        else:
            formatted_date = upload_date
        
        # Mostra risultati
        print("\n" + "="*60)
        print("üìä METADATI VIDEO")
        print("="*60)
        print(f"Titolo: {metadata['title']}")
        print(f"Canale: {metadata['channel']}")
        print(f"Data: {formatted_date}")
        print(f"Link: {clean_url}")
        
        print("\n" + "="*60)
        print("üìã SINTESI")
        print("="*60)
        print(summary)
        
        print("\n" + "="*60)
        print("üìù TRASCRIZIONE MIGLIORATA")
        print("="*60)
        print(improved_transcript)
        
        # Salvataggio obbligatorio
        print("\nüíæ Salvando trascrizione completa...")
        filename = f"trascrizione_{clean_url.split('/')[-1]}.txt"
        
        file_content = f"""# TRASCRIZIONE VIDEO YOUTUBE
# Generata il: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## METADATI VIDEO
Titolo: {metadata['title']}
Canale: {metadata['channel']}
Data pubblicazione: {formatted_date}
Durata: {metadata['duration']} secondi
Visualizzazioni: {metadata['view_count']:,}
Link: {clean_url}

## SINTESI
{summary}

## TRASCRIZIONE MIGLIORATA
{improved_transcript}

---
Trascritto con YouTube Transcriber v3.0
Groq Whisper + OpenAI GPT-4o-mini
"""
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(file_content)
        print(f"‚úÖ Salvato in: {filename}")
        
    except Exception as e:
        print(f"‚ùå Errore: {e}")

def process_audio_file(file_path):
    """Processa file audio locale"""
    groq_key, openai_key = get_api_keys()
    if not groq_key or not openai_key:
        return
    
    try:
        if not os.path.exists(file_path):
            print(f"‚ùå File non trovato: {file_path}")
            return
        
        size_mb = os.path.getsize(file_path) / (1024 * 1024)
        if size_mb > 25:
            print(f"‚ö†Ô∏è File troppo grande: {size_mb:.1f}MB (limite: 25MB)")
            return
        
        print(f"üé§ Trascrivendo... ({size_mb:.1f}MB)")
        raw_transcript = transcribe_audio(file_path, groq_key)
        
        print("ü§ñ Migliorando trascrizione...")
        improved_transcript = improve_transcript_with_openai(raw_transcript, openai_key)
        
        print("üìù Generando sintesi...")
        summary = generate_summary(improved_transcript, openai_key)
        
        # Mostra risultati
        print("\n" + "="*60)
        print("üìä METADATI FILE")
        print("="*60)
        print(f"File: {os.path.basename(file_path)}")
        print(f"Percorso: {file_path}")
        print(f"Dimensione: {size_mb:.1f}MB")
        
        print("\n" + "="*60)
        print("üìã SINTESI")
        print("="*60)
        print(summary)
        
        print("\n" + "="*60)
        print("üìù TRASCRIZIONE MIGLIORATA")
        print("="*60)
        print(improved_transcript)
        
        # Salvataggio obbligatorio
        print("\nüíæ Salvando trascrizione completa...")
        base_name = os.path.splitext(os.path.basename(file_path))[0]
        filename = f"trascrizione_{base_name}.txt"
        
        file_content = f"""# TRASCRIZIONE FILE AUDIO
# Generata il: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## METADATI FILE
Nome file: {os.path.basename(file_path)}
Percorso: {file_path}
Dimensione: {size_mb:.1f}MB

## SINTESI
{summary}

## TRASCRIZIONE MIGLIORATA
{improved_transcript}

---
Trascritto con YouTube Transcriber v3.0
Groq Whisper + OpenAI GPT-4o-mini
"""
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(file_content)
        print(f"‚úÖ Salvato in: {filename}")
        
    except Exception as e:
        print(f"‚ùå Errore: {e}")

def is_youtube_url(text):
    """Controlla se il testo √® un URL YouTube"""
    return any(domain in text.lower() for domain in ['youtube.com', 'youtu.be', 'youtube.be'])

def main():
    # Gestione argomenti
    if len(sys.argv) == 1:
        # Modalit√† interattiva
        interactive_mode()
    elif len(sys.argv) == 2:
        arg = sys.argv[1]
        
        if arg in ['--help', '-h', 'help']:
            show_help()
        elif arg in ['--setup', 'setup']:
            setup_api_keys()
        elif is_youtube_url(arg):
            process_youtube(arg)
        elif os.path.exists(arg):
            process_audio_file(arg)
        else:
            print(f"‚ùå File non trovato o URL non valido: {arg}")
            print("üí° Usa 'transcribe --help' per aiuto")
    else:
        print("‚ùå Troppi argomenti")
        print("üí° Usa 'transcribe --help' per aiuto")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\nüëã Interrotto dall'utente")
    except Exception as e:
        print(f"‚ùå Errore imprevisto: {e}")
